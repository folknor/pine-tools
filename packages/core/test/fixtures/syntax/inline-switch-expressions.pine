// @test syntax/inline-switch-expressions
// @expects parse: success

// Inline switch expressions returning tuples

// Basic inline switch with tuple result
[a, b] = switch x
    1 => [10, 20]
    2 => [30, 40]
    => [0, 0]

// Inline switch in for loop
for i = 0 to 10
    [val, flag] = switch i % 3
        0 => [100, true]
        1 => [200, false]
        => [0, na]
    process(val, flag)

// Inline switch with complex conditions
[r1, r2] = switch
    cond1 and cond2 => [1, 2]
    cond3 or cond4 => [3, 4]
    not cond5 => [5, 6]
    => [7, 8]

// Note: Deeply nested inline switches with tuple assignments inside case bodies
// are not yet fully supported. Basic inline switch with tuples works.

// Multiple tuple assignments from switches in sequence
[x1, y1] = switch a
    1 => [1, 1]
    => [0, 0]
[x2, y2] = switch b
    2 => [2, 2]
    => [0, 0]
[x3, y3] = switch c
    3 => [3, 3]
    => [0, 0]

// Switch with function calls in tuple result
[p, q] = switch mode
    Fast => [quick(), rapid()]
    Slow => [steady(), gradual()]
    => [na, na]

// Switch with method calls in tuple result
[m, n] = switch source
    Array => [arr.first(), arr.last()]
    Matrix => [mat.get(0, 0), mat.get(1, 1)]
    => [na, na]

// Switch in while loop body
while active
    [state, value] = switch phase
        1 => [nextPhase(), compute()]
        2 => [finalPhase(), result()]
        => [0, 0.0]
    if state == 0
        active := false

// Switch in if-else branches
if useSwitch
    [s1, s2] = switch variant
        A => [1, 2]
        B => [3, 4]
        => [5, 6]
else
    [s1, s2] = [0, 0]

// Chained switches with tuple intermediates
[t1, t2] = switch first
    X => [1, 2]
    => [0, 0]
[t3, t4] = switch second
    Y => [t1 * 2, t2 * 2]
    => [t1, t2]
finalResult = t3 + t4
