//@version=6
indicator("Dominant Structure Test")

// Test function with the exact structure from dominant-v1.pine
ehlers_dft_adapted_rsi(price, window, overbought, oversold, frac) =>
    // Initialize variables
    var float hp = 0.0
    var float cleaned_data = 0.0
    var float per = 0.0
    var float cos_per = 0.0
    var float cyc_per = 0.0
    var float alpha1 = 0.0
    var float max_pwr = 0.0
    var float three_minus = 0.0
    var float dominant_cycle = 0.0
    var float change = 0.0
    var float abs_change = 0.0

    // Return value
    var float dft_rsi = 0.0

    // XXX Should these be vars?
    float num = 0.0
    float denom = 0.0

    // Initialize arrays
    var array<float> cosine_part = array.new_float(52)
    var array<float> sine_part = array.new_float(52)
    var array<float> pwr = array.new_float(52)
    var array<float> db = array.new_float(52)
    var array<float> sf = array.new_float(52)
    var array<float> net_chg_avg = array.new_float(52)
    var array<float> tot_chg_avg = array.new_float(52)
    var array<float> rsi_array = array.new_float(52)

    // Detrend data
    if bar_index <= 4
        // Use raw price in the beginning
        hp := price
        cleaned_data := price
        cleaned_data
    else if bar_index > 4
        // High-pass filter with a 40-bar period
        per := 2 * math.pi / 40
        cos_per := math.cos(per)
        alpha1 := cos_per != 0 ? (1 - math.sin(per)) / cos_per : alpha1
        hp := 0.5 * (1 + alpha1) * (price - nz(price[1])) + alpha1 * nz(hp[1])
        // 6-bar Super Smoother
        cleaned_data := (hp + 2 * nz(hp[1]) + 3 * nz(hp[2]) + 3 * nz(hp[3]) + 2 * nz(hp[4]) + nz(hp[5])) / 12
        cleaned_data

    // Calculate Adaptive RSI (Lines 68-83)
    // Calculates RSI for multiple window sizes (1 to window)
    // Uses exponential smoothing instead of traditional SMA
    for count = 1 to window by 1
        // Exponentially Smoothed RSI (ERSI)
        // sf = smoothing factor, 1/count
        // net_chg_avg / tot_chg_avg = net/total change averages, calculated
        //                             using an EMA with the smoothing factor sf.
        if bar_index == 0
            // Set the smoothing factor for each RSI window size (count).
            // This is a constant based on the lookback period
            array.set(sf, count, 1 / count)
            array.set(net_chg_avg, count, (price - nz(price[count])) / count)
            // XXX Add option to change MA type?
            // XXX Also surely `count` here is always 1? This only ever runs on the first bar, right? Why are we averaging it?
            array.set(tot_chg_avg, count, ta.sma(abs_change, count))  // This should trigger CONDITIONAL_SERIES warning
        else
            array.set(net_chg_avg, count, nz(array.get(net_chg_avg, count)[1]) + nz(array.get(sf, count)) * (change - nz(array.get(net_chg_avg, count)[1])))
            //array.set(net_chg_avg, count, nz(array.get(net_chg_avg, count))[1] + nz(array.get(sf, count)) * (change - nz(array.get(net_chg_avg, count))[1]))

            array.set(tot_chg_avg, count, nz(array.get(tot_chg_avg, count)[1]) + nz(array.get(sf, count)) * (abs_change - nz(array.get(tot_chg_avg, count)[1])))
            if nz(array.get(tot_chg_avg, count)) != 0
                array.set(rsi_array, count, 50 * (nz(array.get(net_chg_avg, count)) / nz(array.get(tot_chg_avg, count)) + 1))
            else
                array.set(rsi_array, count, 50)

    // Selects RSI based on frac * dominant_cycle
    // If result > 50, caps at 50
    dft_rsi := nz(array.get(rsi_array, frac * dominant_cycle < 50 ? math.ceil(frac * dominant_cycle) : 50))

    [dft_rsi]

// Call the function
[rsi] = ehlers_dft_adapted_rsi(close, 30, 55, 45, 0.4)